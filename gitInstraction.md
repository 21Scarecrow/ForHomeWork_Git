![Тут должно быть logo](Git_logo.jpg)
# Инструкция по **Git**

## 1. Проверка наличия установленного **Git**

В терминале выполняем команду *git version*. Если **Git** установлен, то появится сообщение с информацией о версии файла, иначе будет сообщение об ошибке.
## 2. Установка **Git**

Установка **Git** в операционной системе Windows.

Достаточно зайти на сайт http://git-scm.com/download/win, и загрузка начнется автоматически. После этого программу необходимо установить обычным способом.

## 3. Настройка **Git**

При первом использовании **Git** необходимо представиться. Для этого надо ввести 2 команды:
* *git config --global user.name "username"*
* *git config --global user.email "email"*

Для того, чтобы проверить прошла ли регистрация надо ввести команду:
* *git config --list*

Затем найти строчки, которые в случае удачной регистрации будут выглядеть примерно вот так:\
![регистрация](registr.png)

## 4. Инициализация Репозитория

Прописываем команду *git init*. В исходной папке появится скрытая папка **.git**

## 5. Проверка состояния файлов

Основным инструментом определения состояния файлов является команда *git status*. Если в рабочей папке остуствуют отслеживаемые и измененные файлы эта команда дает примерно такой результат:

> ![Screen_status](Status.png)

   Кроме того, система **Git** не обнаружила неотслеживаемых файлов, в противном случае они были бы перечислены в выводимых командой данных. Наконец, команда сообщает имя ветки, на которой вы в данный момент находитесь, и информирует о  совпадении состояний этой ветки и аналогичной ветки на сервере.

## 6. Слежение за новыми файлами

Чтобы начать слежение за новым файлом, воспользуйтесь командой *git add*. К примеру, для файла gitInstraction.md она будет выглядеть так:
* *git add .\gitInstraction.md*

Теперь команда *status* покажет, что этот файл является отслеживаемым и проиндексированным.

Все проиндексированные файлы перечисляются под заголовком Changes to be committed. Если в этот момент произвести фиксацию, версия файла, существовавшая на момент выполнения команды *git add*, попадет в историю снимков состояния.

Для отмены индексирования используется команда *git reset HEAD file_name*

## 7. Просмотр индексированных и неиндексированных изменений

Если команда *git status* дает недостаточно подробный, с вашей точки зрения,  результат, например если вы хотите не только получить список отредактированных файлов, но и узнать, что именно изменилось, воспользуйтесь командой *git diff*. Чаще всего вы будете пользоваться ею для ответа на два вопроса: что вы отредактировали (но пока не проиндексировали) и что из проиндексированного готово к фиксации? Команда *git status* отвечает на эти вопросы в общей форме, перечисляя имена файлов, а вот команда *git diff* показывает добавленные и удаленные строки — то есть все вставки в программу.

## 8. Фиксация изменений

Теперь, когда область индексирования настроена нужным вам образом, можно зафиксировать внесенные туда изменения. Помните, что все, оставленное неиндексированным, в том числе любые созданные или измененные файлы,  для которых после редактирования не была выполнена команда *git add*, в текущий коммит не войдет. Все эти файлы останутся на вашем диске как измененные. Впрочем, в рассматриваемом сейчас примере мы будем считать, что последний запуск команды *git status* показал все файлы как проиндексированные и все готово к фиксации изменений. Проще всего осуществить фиксацию командой:
* *git commit -m "комментарий"*
* *git commit -am "комментарий"* - для индексирования и фиксации одной командой.

## 9. Просмотр истории версий

После сохранения нескольких версий файлов или клонирования уже имеющего содержимое репозитория вы, скорее всего, захотите взглянуть на то, что было сделано ранее. Базовым и самым мощным инструментом в данном случае является команда:
* *git log*

По умолчанию при отсутствии параметров команда *git log* выводит в обратном хронологическом порядке список сохраненных в данный репозиторий версий. То есть первыми показываются самые свежие коммиты.  Рядом с каждым коммитом указывается его контрольная сумма SHA-1, имя и электронная почта автора, дата создания и сообщение о фиксации.

У команды *git log* существует великое множество параметров, позволяющих вывести именно ту информацию, которая вам требуется. Одним из самых полезных является параметр *-p*, показывающий разницу, внесенную каждым коммитом. А дополнительный параметр *-2* ограничивает выводимый результат последними двумя записями. Параметр *oneline* выводит каждый коммит в одну строку, что весьма удобно при просмотре большого числа коммитов.

![git log parameters](git_log.png)

## 10. Получение старых коммитов и навигация по существующим веткам репозитория

Основная функция *git checkout* это перемещать указатель HEAD, т.е. то куда смотрит ваша локальная копия. Вы можете переместить его на вершину ветки: *git checkout <branch>* или на отдельный коммит: *git checkout <sha>*. Ну а вспомогательные это создание веток: *git checkout -b*, отмена изменений в файле: *git checkout -- <file>*

## 11. Добавление картинок и игнорирование файлов

Для добавления картинки в наш файл необходимо добавить ее в папку с репозиторием и после этого в нужном месте пишем следующее:\
 ![Подпись](имя файла с расширением)

Для того, чтобы удалить файлы с изображениями из отслеживания, надо создать файл *.gitignore*

## 12. Ветвление

Для создания новой ветки необходимо ввести в терминале команду *git branch branch_name*.

Ветвление необходимо для работы с файлами в отдельной ветке, сохраняя при этом исходное состояние файла до их слияния.

Чтобы отобразить созданные ветки, используется команда *git branch*.

Чтобы перейти на другую ветку используется команда *git checkout branch_name*.

Для удаления ветки используется команда *git branch -d branch_name*

## 13. Слияние веток

Для слияния веток и внесения изменений в наш основной файл используется команда *git merge branch_name*. Слияние делается в ту ветку, в которой мы находимся сейчас.

## 14. Конфликты

Хочу увидеть конфликт


Тут точно должен быть конфликт
Сто пудова
Очень нужен конфликт
Хочу увидеть конфликт

Конфликты возникают при слиянии двух веток в одну, при этом должна быть изменена одна и таже строка файла.\
Конфликт выглядит вот так:
![Конфликт](conflict.png)

## 15. Псевдонимы в Git

Есть способы как сделать работу с **Git** проще, удобнее и привычнее. Речь идет о псевдонимах (aliases).

При неполном вводе команды Git не пытается догадаться, что за команду вы имели в виду. Но если мысль о вводе длинных команд вас не привлекает, команда git config позволяет легко создать псевдоним для любой из них. Вот пара примеров ее применения:\
git config --global alias.co checkout\
git config --global alias.br branch\
git config --global alias.ci commit\
git config --global alias.st status\
Теперь вместо команды *git commit* достаточно будет ввести *git ci*. По мере освоения **Git**, скорее всего, придется часто пользоваться и другими командами.\
Кроме того, эта техника позволяет создавать команды, которых, с вашей точки зрения, не хватает. К примеру, чтобы отменить индексирование файла, можно добавить псевдоним unstage:\
git config --global alias.unstage 'reset HEAD --'\
После этого следующие команды станут эквивалентными:\
* git unstage fileA
* git reset HEAD fileA

В таком виде все выглядит понятнее. Также пользователи частенько добавляют команду, выводящую последние коммиты:\
git config --global alias.last 'log -1 HEAD'\
Теперь для просмотра последнего коммита достаточно написать:\
git last

![alias](alias.png)


Домашка
Мне нужен конфликт для домашки
Давай мне конфликт, очень надо

![Конфликт в домашке](Conflict2.png)